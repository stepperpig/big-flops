# After experimenting with local caches in load_cache.py, we notice that
# IO still dominates runtime. This time, we're dealing with disk access.
# So let's consider a case where the CPU is the limiting factor.

# We'll take all stations in the NOAA database and compute the distance
# between them, a problem of complexity n2.

import csv
import math

def get_locations():
    with open("locations.csv", "rt") as f:
        reader = csv.reader(f)
        header = next(reader)
        for row in reader:
            station = row[header.index("STATION")]
            lat = float(row[header.index("LATITUDE")])
            lon = float(row[header.index("LONGITUDE")])
            yield station, (lat, lon)

# Use the haversine formula to calculate the distance
# between two coordinates.
def get_distance(p1, p2):
    lat1, lon1 = p1
    lat2, lon2 = p2

    lat_dist = math.radians(lat2-lat1)
    lon_dist = math.radians(lon2-lon1)
    a = (
        math.sin(lat_dist / 2) * math.sin(lat_dist / 2) +
        math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) *
        math.sin(lon_dist / 2) * math.sin(lon_dist / 2)
    )
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
    earth_radius = 6371
    dist = earth_radius * c

    return dist

# We're comparing stations between each other
def get_distances(stations, locations):
    distances = {}
    for first_i in range(len(stations) - 1):
        first_station = stations[first_i]
        first_location = locations[first_station]
        for second_i in range(first_i, len(stations)):
            second_station = stations[second_i]
            second_location = locations[second_station]
            distances[(first_station, second_station)] = get_distance(first_location, second_location)
    return distances

locations = { station: (lat, lon) for station, (lat, lon) in get_locations() }
stations = sorted(locations.keys())
distances = get_distances(stations, locations)